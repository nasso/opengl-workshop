<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenGL Workshop</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li class="chapter-item expanded "><a href="hello-triangle/index.html"><strong aria-hidden="true">3.</strong> Hello, Triangle!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-triangle/clear.html"><strong aria-hidden="true">3.1.</strong> Clearing the screen</a></li><li class="chapter-item expanded "><a href="hello-triangle/shaders.html"><strong aria-hidden="true">3.2.</strong> Your own shader program</a></li><li class="chapter-item expanded "><a href="hello-triangle/vertex-array.html"><strong aria-hidden="true">3.3.</strong> Creating a vertex array</a></li><li class="chapter-item expanded "><a href="hello-triangle/drawing.html"><strong aria-hidden="true">3.4.</strong> Drawing the triangle</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Hello, Textured Cube!</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Basic lightning</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Normal mapping</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Shadow mapping</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Physically based rendering techniques</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Ray-tracing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> GTA VI tutorial</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">OpenGL Workshop</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- markdownlint-disable MD033 -->
<!-- markdownlint-disable MD041 -->
<img class="light-only" src="res/OpenGL_170px_June16.png">
<img class="dark-only" src="res/OpenGL_White_170px_June16.png">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to my OpenGL workshop! This workshop will walk you through the very
basics of the modern OpenGL API (&gt;= 3.3). By the end of it, you should have a
rough understanding of how the API is structured and how it can be used to
render simple hardware accelerated shapes.</p>
<h2 id="whats-opengl"><a class="header" href="#whats-opengl">What's OpenGL?</a></h2>
<p>OpenGL is a graphics API that gives you the power to use your video card for
graphical rendering. Without it, you would have to manually compute the colour
for every single pixel you would like to draw using the CPU. That's horrendously
slow, because you have to iterate through every single pixel one by one in
sequence!</p>
<p>Instead, many computers have a Graphical Processing Unit (GPU for short). It is
much more efficient because it's able to render different parts of your scene in
parallel! To be able to communicate with it in your programs, many different
APIs exist, each with a different set of capabilities and platform support.</p>
<p>The following table (that I just made up myself) summarises platform support for
the most common graphics APIs out there:</p>
<table><thead><tr><th align="right">Platform</th><th align="center">OpenGL</th><th align="center">Direct3D (DirectX)</th><th align="center">Vulkan</th><th align="center">Metal</th></tr></thead><tbody>
<tr><td align="right">Windows</td><td align="center">++</td><td align="center">+++</td><td align="center">++</td><td align="center">-</td></tr>
<tr><td align="right">Linux</td><td align="center">++</td><td align="center">-</td><td align="center">+++</td><td align="center">-</td></tr>
<tr><td align="right">Android</td><td align="center">++</td><td align="center">-</td><td align="center">+++</td><td align="center">-</td></tr>
<tr><td align="right">Mac</td><td align="center">+</td><td align="center">-</td><td align="center">+*</td><td align="center">+++</td></tr>
<tr><td align="right">iOS</td><td align="center">+</td><td align="center">-</td><td align="center">+*</td><td align="center">+++</td></tr>
<tr><td align="right">Switch</td><td align="center">+</td><td align="center">-</td><td align="center">++</td><td align="center">-</td></tr>
<tr><td align="right">Xbox</td><td align="center">-</td><td align="center">+++</td><td align="center">-</td><td align="center">-</td></tr>
</tbody></table>
<p>*: non-official support through third-party software</p>
<blockquote>
<p>The name of the Xbox comes from DirectX (it's a &quot;direct-X Box&quot;). The
PlayStation by Sony has its own proprietary API, and <a href="https://www.reddit.com/r/gamedev/comments/7jcugl/anyone_know_if_the_switch_has_its_own_graphics_api/">the Nintendo Switch also
supports NVN</a>, an API developed by NVIDIA.</p>
</blockquote>
<h2 id="what-are-we-making"><a class="header" href="#what-are-we-making">What are we making?</a></h2>
<p>Most programmers begin to learn a new language or technology by writing a simple
&quot;Hello, World!&quot; program. In the world of low-level graphics programming, the
equivalent is the well known &quot;RGB triangle&quot;:</p>
<p><img src="./hello-triangle/res/win_triangle.png" alt="The RGB triangle" /> <em>Hello, Triangle!</em></p>
<p>Being a low level API, OpenGL requires us to follow quite a bunch of steps in
order to reach our goal:</p>
<ol>
<li>Create a shader program</li>
<li>Create a buffer containing vertex coordinates</li>
<li>Create a buffer containing vertex colours</li>
<li>Define a vertex array using the two buffers</li>
<li>Clear the screen</li>
<li>Draw 3 vertices using our shader program and vertex array</li>
</ol>
<p>Don't worry, we'll go through each of those steps one by one!</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<blockquote>
<p>You can follow this workshop on Windows!</p>
</blockquote>
<p>I have prepared <a href="https://github.com/nasso/opengl-workshop">a repository</a>
containing several utilities that aren't relevant to this workshop (e.g. to open
a window, create an OpenGL context or load a bitmap file). This way, you'll be
focused on the important parts of today's workshop: OpenGL!</p>
<p>Clone it somewhere on your computer to get started:</p>
<pre><code class="language-sh">git clone https://github.com/nasso/opengl-workshop.git
</code></pre>
<blockquote>
<p>You should have <code>cmake</code> installed (at least version 3.11).</p>
</blockquote>
<p>Then try to build and run it!</p>
<pre><code class="language-sh">mkdir build         # create a `build/`
cmake . -B build    # configure a CMake build in the `build/` directory
cmake --build .     # build the executable
./main              # run it!
</code></pre>
<p>At this point, you should see an empty window appear!</p>
<p><img src="./res/win_empty.png" alt="Empty Window" /> <em>An empty window!</em></p>
<p>When modifying your code (in <code>src/main.c</code> for instance), you'll only have to
re-run the last two commands to see your changes:</p>
<pre><code class="language-sh">cmake --build . # re-build (only necessary files)
./main          # re-run!
</code></pre>
<blockquote>
<p>You shouldn't have to re-configure! CMake should automatically re-configure
the build when deemed necessary.</p>
</blockquote>
<h1 id="hello-triangle"><a class="header" href="#hello-triangle">Hello, Triangle!</a></h1>
<p>Traditionally, when learning a new language or technology, us programmers enjoy
writing a simple program displaying, in some way, &quot;Hello, World!&quot;.</p>
<p>Now, in the world of low-level graphics programming, displaying text is already
quite a complex task. In fact, it's probably one of the hardest things to do
properly on today's GPUs.</p>
<p>Instead, graphics programmers have their own tradition: the RGB triangle! Here's
what you should have at the end of this chapter:</p>
<p><img src="hello-triangle/./res/win_triangle.png" alt="The RGB Triangle" /> <em>Hello, <del>World</del> Triangle!</em></p>
<h1 id="clearing-the-screen"><a class="header" href="#clearing-the-screen">Clearing the screen</a></h1>
<p>Right now, your window probably doesn't show anything exciting yet. Let's change
that!</p>
<p>Use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClear.xhtml"><code>glClear</code></a> and <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glClearColor.xhtml"><code>glClearColor</code></a> to clear the framebuffer of your window
using the colour of your choice! Do it in the <code>render</code> function callback to
clear the screen every time before anything gets drawn.</p>
<p><img src="hello-triangle/./res/win_clear.png" alt="A cleared window" /> <em>I went with some dark shade of grey.</em></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/">OpenGL 4 Reference Pages</a> - the official documentation</li>
<li><a href="http://docs.gl">docs.gl</a> - a nicer documentation, though unofficial</li>
</ul>
<h1 id="your-own-shader-program"><a class="header" href="#your-own-shader-program">Your own shader program</a></h1>
<p>Finally, the time has come! The time for what you ask? Well, to write your very
own pair of GLSL shaders of course!</p>
<p>You might be wondering what I'm talking about, so let's reiterate, shall we?</p>
<h2 id="what-is-a-shader"><a class="header" href="#what-is-a-shader">What is a shader?</a></h2>
<p>Shaders are pieces of software that run on your GPU. They are used to perform
specialised calculations based on a set of inputs in parallel. They are written
in a language specific to the graphics API you're using. The <em>OpenGL Shading
Language</em>, abbreviated as <em>GLSL</em>, is the one we're going to use today.</p>
<blockquote>
<p>Don't worry! GLSL is actually very close to C! It just comes with fancy
features that make it easier to write shaders: types such as <code>vec2</code>, <code>vec3</code>,
<code>vec4</code> to represent vectors and built-in mathematical functions like
<code>distance</code>, <code>normalize</code> and <code>cross</code>.</p>
</blockquote>
<p>Depending on their role in the graphics pipeline, shaders can take several
names:</p>
<h3 id="vertex-shaders"><a class="header" href="#vertex-shaders">Vertex shaders</a></h3>
<p>The first step when rendering anything, is to give a position to each vertex.
This is exactly what the <em>vertex shader</em> is for! It is executed once for each
vertex, to calculate its coordinates on screen. Typically, this is where you
would apply transformations and 3D projections.</p>
<pre><code class="language-glsl">#version 330 core

layout(location = 0) in vec2 a_Position;

void main() {
    gl_Position = vec4(a_Position, 0.0, 1.0);
}
</code></pre>
<p>Here are a couple things to note about this example shader:</p>
<ul>
<li>It written in GLSL 3.30 and uses the <code>core</code> API profile (the profile we're
using).</li>
<li>It has a single input: <code>a_Position</code>, a 2D vector. The <code>layout(location = 0)</code>
part just means &quot;this is input #0&quot;.</li>
<li>It constructs a 4D vector from <code>a_Position</code> and stores it into <code>gl_Position</code>.
The <code>z</code> component is set to <code>0.0</code> and <code>w</code> (the fourth component) is set to
<code>1.0</code>.</li>
</ul>
<p>The main output of our vertex shader is the <code>gl_Position</code> variable, holding the
coordinates of a single point of the geometry we're drawing on screen!</p>
<blockquote>
<p>You might wonder why <code>gl_Position</code> is a <code>vec4</code> instead of a <code>vec2</code> or a
<code>vec3</code>. This has to do with something called <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">homogeneous coordinates</a>. Don't
worry too much about it for now, just keep in mind that <code>w</code> should be set to
<code>1.0</code>!</p>
</blockquote>
<p>The inputs of a vertex shader can be anything you want! For example, you could
keep it simple and just feed it plain 2D coordinates like in the example above.
But you could also feed it 3D coordinates and matrices, and let it do the math
to figure out the final 2D position! Don't worry, your GPU <em>loves</em> doing math.</p>
<h4 id="exercise-compiling-a-vertex-shader"><a class="header" href="#exercise-compiling-a-vertex-shader">Exercise: compiling a vertex shader</a></h4>
<p>To create a shader, you can use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml"><code>glCreateShader</code></a>. Once created, you can load
the GLSL source code with <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glShaderSource.xhtml"><code>glShaderSource</code></a> and compile it with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCompileShader.xhtml"><code>glCompileShader</code></a>. To make it easier for you to write your shaders in separate
files (typically <code>*.vs</code> for vertex shaders and <code>*.fs</code> for fragment shaders),
I've written a helper function to read a file in a heap-allocated string:</p>
<pre><code class="language-c">char* source = read_file(&quot;./res/my_shader.vs&quot;);

GLuint shader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(shader, 1, &amp;source, NULL);
glCompileShader(shader);

// don't forget to free the shader source string!
free(source);
</code></pre>
<p>Just don't forget to <code>#include &quot;utils.h&quot;</code> at the top of your C source file.</p>
<p>Try creating and compiling a vertex shader (for instance, the above example)
using those functions.</p>
<blockquote>
<p>You can use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml"><code>glGetShaderiv</code></a> and <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml"><code>glGetShaderInfoLog</code></a> to see if your shader
successfully compiled! Try inserting a syntax error and see if you can get a
meaningful error message from it.</p>
</blockquote>
<h3 id="fragment-or-pixel-shaders"><a class="header" href="#fragment-or-pixel-shaders">Fragment (or pixel) shaders</a></h3>
<p>After the vertex shader computed the positions of each triangle (GPUs can only
draw triangles), the next step is to actually fill them with colourful pixels!
Now, to decide what colour each pixel takes, another kind of shader is executed:
the <em>fragment shader</em> (also known as <em>pixel shader</em>).</p>
<blockquote>
<p>Yes, it is executed for each individual pixel on screen. That means cycles are
precious at this stage! Luckily, this is what modern GPUs are optimised for.</p>
</blockquote>
<p>Unlike the vertex shader, you cannot <em>directly</em> feed per-pixel input to your
fragment shader. However, you can pass variables from your vertex shader to your
fragment shader! Different values between two vertices will be linearly
interpolated.</p>
<pre><code class="language-glsl">#version 330 core

// coming from an output of the vertex shader!
in vec3 v_Color;

// the final colour of the pixel!
out vec4 o_Color;

void main() {
    o_Color = vec4(v_Color, 1.0);
}
</code></pre>
<h4 id="exercise-compiling-a-fragment-shader"><a class="header" href="#exercise-compiling-a-fragment-shader">Exercise: compiling a fragment shader</a></h4>
<p>Fragment shaders are compiled the exact same way as vertex shaders (don't forget
to specify <code>GL_FRAGMENT_SHADER</code> when creating it though).</p>
<blockquote>
<p>Because of how similar it is to compile vertex and fragment shaders, maybe you
could write a helper function to do it for you...</p>
</blockquote>
<h2 id="a-shader-program"><a class="header" href="#a-shader-program">A shader program</a></h2>
<p>You now have a vertex shader and a fragment shader compiled! It's now time to
link them together, just like you would link two object files together to get a
full program.</p>
<p>The function to do that is conveniently called <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml"><code>glLinkProgram</code></a>. Use it to link
a shader program for the two shaders you have compiled.</p>
<blockquote>
<p>Just like compilation, linkage can fail! You can use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgram.xhtml"><code>glGetProgramiv</code></a> and
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml"><code>glGetProgramInfoLog</code></a> to get information about any error that occurred when
linking your shaders.</p>
</blockquote>
<p>Did it successfully link? In your vertex shader, add an input similar to
<code>a_Position</code> called <code>a_Color</code>, and pass its value to the fragment shader using
an <code>out</code> variable (they must share the same name in the two shaders).</p>
<h1 id="creating-a-vertex-array"><a class="header" href="#creating-a-vertex-array">Creating a vertex array</a></h1>
<p>You should now have a pair of shaders that are compiled and linked together to
form a shader program!</p>
<p>The next step will be to actually feed data to our program! The graphics
pipeline starts with the <em>Vertex Shader</em>, so we have to provide it <em>per-vertex
data</em>. We do so by creating what is called a <em>Vertex Array</em> (makes sense,
right?).</p>
<p>Our triangle is made up of three vertices, so we will need three entries in our
vertex array. In the following table, each line represents a vertex in our
vertex array:</p>
<table><thead><tr><th align="center">X position</th><th align="center">Y position</th></tr></thead><tbody>
<tr><td align="center"><code>0.0</code></td><td align="center"><code>0.5</code></td></tr>
<tr><td align="center"><code>-0.5</code></td><td align="center"><code>0.5</code></td></tr>
<tr><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td></tr>
</tbody></table>
<p>A vertex can have any sort of data associated with it, not just its position!
For instance, we can associate a colour to each vertex:</p>
<table><thead><tr><th align="center">X position</th><th align="center">Y position</th><th align="center">Red</th><th align="center">Green</th><th align="center">Blue</th></tr></thead><tbody>
<tr><td align="center"><code>0.0</code></td><td align="center"><code>0.5</code></td><td align="center"><code>1.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td></tr>
<tr><td align="center"><code>-0.5</code></td><td align="center"><code>0.5</code></td><td align="center"><code>0.0</code></td><td align="center"><code>1.0</code></td><td align="center"><code>0.0</code></td></tr>
<tr><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>1.0</code></td></tr>
</tbody></table>
<h2 id="buffers"><a class="header" href="#buffers">Buffers</a></h2>
<p>In OpenGL, as with many other graphics API, a vertex array doesn't directly hold
the data associated with each vertex. Instead, a one-dimensional generic data
structure called a &quot;buffer&quot; is used to store arbitrary data that can then be
used to construct a vertex array.</p>
<p>Keeping the example above, we could have a buffer storing 2D vertex positions:</p>
<table><thead><tr><th align="center">X1</th><th align="center">Y1</th><th align="center">X2</th><th align="center">Y2</th><th align="center">X3</th><th align="center">Y3</th></tr></thead><tbody>
<tr><td align="center"><code>0.0</code></td><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td><td align="center"><code>0.5</code></td><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td></tr>
</tbody></table>
<p>Because buffers are one-dimensional data structures, vertex coordinates have to
be stored in an interleaved layout (<code>X1, Y1, X2, Y2, ...XN, YN</code>).</p>
<p>OpenGL provides a couple functions to manipulate buffers:</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml"><code>glGenBuffers</code></a>: to create buffers</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml"><code>glDeleteBuffers</code></a>: to destroy buffers</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"><code>glBufferData</code></a>: to set the buffer contents</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"><code>glBindBuffer</code></a>: to &quot;bind&quot; buffers (more on that in the next section)</li>
</ul>
<h3 id="the-opengl-state-machine"><a class="header" href="#the-opengl-state-machine">The OpenGL state machine</a></h3>
<p>When programming with the OpenGL API, you will encounter many <code>glBind*</code>
functions. This is because OpenGL was designed around the concept of a &quot;state
machine&quot; where objects must be bound before being manipulated. In other words,
<strong>you cannot use <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"><code>glBufferData</code></a> before having bound your buffer with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"><code>glBindBuffer</code></a></strong>:</p>
<pre><code class="language-c">// first, bind the buffer...
glBindBuffer(GL_ARRAY_BUFFER, my_buffer);
// now that it is the current GL_ARRAY_BUFFER, you can set its data!
glBufferData(GL_ARRAY_BUFFER, /* ... */);
</code></pre>
<blockquote>
<p><strong>Pay attention to the arguments of <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml"><code>glBufferData</code></a>!</strong> Look it up... None of
them corresponds <em>directly</em> to the buffer ID you want to manipulate.</p>
</blockquote>
<h3 id="buffers-checkpoint"><a class="header" href="#buffers-checkpoint">Buffers: checkpoint</a></h3>
<p>Back to code! Create the following buffers for the vertex array we will be
creating in the next section:</p>
<table><thead><tr><th align="center">X1</th><th align="center">Y1</th><th align="center">X2</th><th align="center">Y2</th><th align="center">X3</th><th align="center">Y3</th></tr></thead><tbody>
<tr><td align="center"><code>0.0</code></td><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td><td align="center"><code>0.5</code></td><td align="center"><code>0.5</code></td><td align="center"><code>-0.5</code></td></tr>
</tbody></table>
<table><thead><tr><th align="center">R1</th><th align="center">G1</th><th align="center">B1</th><th align="center">R2</th><th align="center">G2</th><th align="center">B2</th><th align="center">R3</th><th align="center">G3</th><th align="center">B3</th></tr></thead><tbody>
<tr><td align="center"><code>1.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>1.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>0.0</code></td><td align="center"><code>1.0</code></td></tr>
</tbody></table>
<p>The first one will contain vertex coordinates, and the second will contain
vertex colours. The data they contain should be an array of <code>float</code>s.</p>
<blockquote>
<p>Don't forget to delete the buffers at the end of your program!</p>
</blockquote>
<h2 id="constructing-the-vertex-array"><a class="header" href="#constructing-the-vertex-array">Constructing the vertex array</a></h2>
<p>You should now have two buffers created, one containing 2D coordinates and the
other containing colours. The last step of the process is to actually build a
vertex array from that data! You can generate an empty vertex array with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml"><code>glGenVertexArrays</code></a>.</p>
<p>Remember the shaders you wrote? In your vertex shader, input variables denoted
with the <code>in</code> keyword correspond to <em>vertex attributes</em>. Each attribute in a
shader has a unique location that can be specified with
<code>layout(location = ...)</code>. When created with <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml"><code>glGenVertexArrays</code></a>, vertex arrays
don't have any attributes: you must enable each location with
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml"><code>glEnableVertexAttribArray</code></a>.</p>
<blockquote>
<p>Don't forget to bind the vertex array with <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml"><code>glBindVertexArray</code></a> before
manipulating it!</p>
</blockquote>
<p>Now that you have enabled each vertex attribute location, the last step is to
specify where the data is, and the answer is... in the buffers of course!</p>
<p>However, the buffers we created don't hold any information regarding the format
in which our data is stored: it's just an array of raw bytes. The vertex shader
expects more sophisticated data types, such as single-precision floating-point
vectors for example.</p>
<p>Thankfully, <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml"><code>glVertexAttribPointer</code></a> lets us specify all of that with a single
function call (minus the call to <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml"><code>glBindBuffer</code></a>)! Its <code>index</code> parameter
corresponds to the attribute location you want to assign data to.</p>
<p>In the end, the code to build the vertex array should look like this:</p>
<pre><code class="language-c">// create the coordinates buffer:
glGenBuffers(...);
glBindBuffer(...);
glBufferData(...);

// same for the buffer storing vertex colours:
/* ... */

// create the vertex array:
glGenVertexArrays(...);
glBindVertexArray(...);

// bind one of the buffer to the vertex attribute it corresponds to:
glEnableVertexAttribArray(...);
glBindBuffer(...);
glVertexAttribPointer(...);

// then do the same for the other attribute!
/* ... */
</code></pre>
<blockquote>
<p><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml"><code>glGenBuffers</code></a> can be used to create several buffers at the same time!</p>
</blockquote>
<p>And that's all you need to render a triangle! Well, almost... In the next
chapter, we will put together everything we've done so far to finally get
something rendered on the screen!</p>
<h1 id="drawing-the-triangle"><a class="header" href="#drawing-the-triangle">Drawing the triangle</a></h1>
<p>You should now have:</p>
<ul>
<li>A shader program that compiles and links</li>
<li>A vertex array providing vertex data for each attribute used by your program</li>
</ul>
<p>The only thing left to do is to draw the three vertices of the triangle using
the program and vertex array we prepared in the previous chapters. To do this,
you'll only need to use three functions:</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUseProgram.xhtml"><code>glUseProgram</code></a>, to specify the shader program</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml"><code>glBindVertexArray</code></a>, to specify the vertex array</li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml"><code>glDrawArrays</code></a>, to draw the vertices!</li>
</ul>
<blockquote>
<p>Up until now, everything went in the <code>init</code> callback function, because the
program and vertex array only need to be created once. However, the triangle
should be redrawn each frame, reusing the shader program and vertex array
every time, so you will probably want to do that in the <code>render</code> callback
function.</p>
</blockquote>
<p>If you did everything right, you should now finally see the triangle show up!</p>
<p><img src="hello-triangle/./res/win_triangle.png" alt="Final result" /> <em>Hello, Triangle!</em></p>
<blockquote>
<p>If you don't see anything: don't worry! Most of us don't get things working
right away on our first try. Check for errors using <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetError.xhtml"><code>glGetError</code></a>, go back a
few chapters, and do not hesitate to ask for help (you're probably not the
only one)!</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
